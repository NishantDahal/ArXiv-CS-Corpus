Understanding Rulelog Computations in Silk

Rulelog is a knowledge representation and reasoning language based on logic programming under the well-founded semantics. It is an extension of the language of Flora-2 and so supports inheritance and other object-oriented features, as well as the higher-order syntax of Hilog. However, Rulelog rules may also contain quantifiers and may be contra-positional. In addition, these rules are evaluated in the presence of defeasibility mechanisms that include rule cancellation, rule priorities, and other aspects. Rulelog programs are sometimes developed by loosely coordinated teams of knowledge engineers (KEs) who are not necessarily programmers. This requires not only declarative debugging support, but also support for profiling to help KEs understand the overall structure of a computation, including its termination properties. The design of debugging and profiling tools is made more challenging because Rulelog programs undergo a series of transformations into normal programs, so that there is a cognitive distance between how rules are specified and how they are executed.
  In this paper, we describe the debugging and profiling environment for Rulelog implemented in the integrated development environment of the Silk system. Our approach includes an interface to justification graphs, which treat why-not and defeasibility as well as provenance of the rules supporting answers. It also includes tools for trace-based analysis of computations to permit understanding of erroneous non-termination and of general performance issues. For semantically correct cases of the non-terminating behavior, Silk offers a different approach, which addresses the problem in a formally sound manner by leveraging a form of bounded rationality called restraint.
