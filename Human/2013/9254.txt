A Swiss Pocket Knife for Computability

This research is about operational- and complexity-oriented aspects of  classical foundations of  computability theory. The approach is to re-examine some  classical theorems and constructions,  but with new criteria for success that are natural  from a  programming language perspective.
  Three cornerstones of computability theory are the  S-m-ntheorem; Turing's  "universal machine"; and  Kleene's second recursion theorem. In today's programming language parlance these are respectively partial evaluation, self-interpretation, and reflection. In retrospect it is fascinating that  Kleene's 1938 proof is constructive; and in essence builds a self-reproducing program.
  Computability theory originated in the 1930s, long before the invention of computers and programs. Its emphasis was on delimiting the boundaries of computability. Some milestones include 1936 (Turing), 1938 (Kleene), 1967 (isomorphism of programming languages), 1985 (partial evaluation), 1989 (theory implementation), 1993 (efficient self-interpretation) and 2006 (term register machines).
  The "Swiss pocket knife"  of the title is a programming language  that allows efficient computer implementation   of  all three computability cornerstones, emphasising the third:  Kleene's second recursion theorem. We describe experiments with a tree-based computational model aiming for both fast program generation and  fast execution of the generated programs.
