Synchronization Strings: List Decoding for Insertions and Deletions

We study codes that are list-decodable under insertions and deletions. Specifically, we consider the setting where a codeword over some finite alphabet of size $q$ may suffer from $δ$ fraction of adversarial deletions and $γ$ fraction of adversarial insertions. A code is said to be $L$-list-decodable if there is an (efficient) algorithm that, given a received word, reports a list of $L$ codewords that include the original codeword.
  Using the concept of synchronization strings, introduced by the first two authors [STOC 2017], we show some surprising results. We show that for every $0\leqδ<1$, every $0\leqγ<\infty$ and every $ε>0$ there exist efficient codes of rate $1-δ-ε$ and constant alphabet (so $q=O_{δ,γ,ε}(1)$) and sub-logarithmic list sizes. We stress that the fraction of insertions can be arbitrarily large and the rate is independent of this parameter. Our result sheds light on the remarkable asymmetry between the impact of insertions and deletions from the point of view of error-correction: Whereas deletions cost in the rate of the code, insertion costs are borne by the adversary and not the code!
  We also prove several tight bounds on the parameters of list-decodable insdel codes. In particular, we show that the alphabet size of insdel codes needs to be exponentially large in $ε^{-1}$, where $ε$ is the gap to capacity above. Our result even applies to settings where the unique-decoding capacity equals the list-decoding capacity and when it does so, it shows that the alphabet size needs to be exponentially large in the gap to capacity. This is sharp contrast to the Hamming error model where alphabet size polynomial in $ε^{-1}$ suffices for unique decoding and also shows that the exponential dependence on the alphabet size in previous works that constructed insdel codes is actually necessary!
