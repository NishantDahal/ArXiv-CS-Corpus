Reversible Communicating Processes

Reversible distributed programs have the ability to abort unproductive computation paths and backtrack, while unwinding communication that occurred in the aborted paths.  While it is natural to assume that reversibility implies full state recovery (as with traditional roll-back recovery protocols), an interesting alternative is to separate backtracking from local state recovery. For example, such a model could be used to create complex transactions out of nested compensable transactions where a programmer-supplied compensation defines the work required to  "unwind" a transaction.
  Reversible distributed computing has received considerable theoretical attention, but little reduction to practice; the few  published implementations of languages supporting reversibility depend upon a high degree of central control.  The objective of this paper is to demonstrate that a practical reversible distributed language can be efficiently implemented in a fully distributed manner.
  We discuss such a language, supporting CSP-style synchronous communication, embedded in Scala. While this language provided the motivation for the work described in this paper, our focus is upon the distributed implementation.  In particular, we demonstrate that a "high-level" semantic model can be implemented using a simple point-to-point protocol.
