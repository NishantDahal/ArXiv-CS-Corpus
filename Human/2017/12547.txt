Malthusian Locks

Applications running in modern multithreaded environments are sometimes \emph{over-threaded}. The excess threads do not improve performance, and in fact may act to degrade performance via \emph{scalability collapse}. Often, such software also has highly contended locks. We opportunistically leverage the existence of such locks by modifying the lock admission policy so as to intentionally limit the number of threads circulating over the lock in a given period. Specifically, if there are more threads circulating than are necessary to keep the lock saturated, our approach will selectively cull and passivate some of those threads. We borrow the concept of \emph{swapping} from the field of memory management and intentionally impose \emph{concurrency restriction} (CR) if a lock is oversubscribed. In the worst case CR does no harm, but it often yields performance benefits. The resultant admission order is unfair over the short term but we explicitly provide long-term fairness by periodically shifting threads between the set of passivated threads and those actively circulating. Our approach is palliative, but often effective.
